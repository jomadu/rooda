# Ralph Loop

An autonomous AI coding methodology that runs Claude in a continuous loop using file-based state to maintain context across iterations.

## Core Concept

Each loop iteration: **read plan > pick task > implement > test > commit > clear context > repeat**

Fresh context each iteration keeps the AI in its "smart zone" (40-60% context utilization). File-based memory (specs, plan, agents file) persists learnings between iterations.

## The Loop Mechanism

```bash
while :; do cat PROMPT.md | claude ; done
```

The IMPLEMENTATION_PLAN.md file persists on disk between iterations and acts as shared state. Each iteration:
1. Loads same files deterministically (PROMPT.md + AGENTS.md + specs/*)
2. Reads current state from IMPLEMENTATION_PLAN.md
3. Picks most important task
4. Implements and commits
5. Updates plan on disk
6. Exits (context cleared)
7. Loop restarts with fresh context

## Two Modes

**PLANNING Mode** - Gap analysis, generates/updates plan
- Compare specs against existing code
- Create prioritized task list in IMPLEMENTATION_PLAN.md
- No implementation

**BUILDING Mode** - Implements from plan
- Pick most important task from plan
- Search codebase (don't assume not implemented)
- Implement with parallel subagents
- Run tests (backpressure)
- Commit when tests pass
- Update plan

## Key Principles

### Context Is Everything
- 200K tokens advertised ≈ 176K usable
- 40-60% utilization = "smart zone"
- Tight tasks + 1 task per loop = 100% smart zone utilization
- Use main agent as scheduler, spawn subagents for work
- Prefer Markdown over JSON for token efficiency

### Steering via Patterns + Backpressure

**Upstream steering:**
- Deterministic setup (same files each loop)
- Existing code patterns guide generation
- Add/update utilities to steer toward correct patterns

**Downstream steering:**
- Tests, typechecks, lints, builds reject invalid work
- PROMPT.md says "run tests" generically
- AGENTS.md specifies actual project commands
- Can extend to LLM-as-judge for subjective criteria

### Let Ralph Ralph
- Trust LLM's ability to self-identify, self-correct, self-improve
- Eventual consistency through iteration
- Plan is disposable - regenerate when wrong/stale
- Run in sandboxed environment (requires `--dangerously-skip-permissions`)

### Move Outside the Loop
- Observe and course correct
- Tune reactively based on failure patterns
- Add "signs" Ralph can discover:
  - Prompt guardrails
  - AGENTS.md operational learnings
  - Utilities in codebase
  - Other discoverable inputs

## File Structure

```
project-root/
├── loop.sh                    # Outer loop script
├── PROMPT_build.md            # Building mode instructions
├── PROMPT_plan.md             # Planning mode instructions
├── AGENTS.md                  # Operational "how to build/test" guide
├── IMPLEMENTATION_PLAN.md     # Task list (generated by Ralph)
├── specs/                     # Requirements (one per JTBD topic)
└── src/                       # Application code
```

### AGENTS.md
- Concise operational guide (~60 lines)
- How to build/run the project
- Project-specific test/build/lint commands
- NOT a changelog or progress diary
- Status/progress belongs in IMPLEMENTATION_PLAN.md

### IMPLEMENTATION_PLAN.md
- Prioritized bullet-point task list
- Generated by Ralph in PLANNING mode
- Updated by Ralph in BUILDING mode
- Can be regenerated anytime

### specs/*
- One markdown file per topic of concern
- Source of truth for what should be built
- Created during requirements phase (human + LLM)

## Workflow

### Phase 1: Define Requirements (LLM conversation)
1. Discuss project ideas > identify Jobs to Be Done (JTBD)
2. Break JTBD into topics of concern
3. LLM writes `specs/FILENAME.md` for each topic

### Phase 2: Planning
```bash
./loop.sh plan
```
- Compare specs against code (gap analysis)
- Generate IMPLEMENTATION_PLAN.md with prioritized tasks
- No implementation

### Phase 3: Building
```bash
./loop.sh
```
- Pick most important task from plan
- Implement with backpressure (tests must pass)
- Commit and update plan
- Loop continues until stopped

## Key Language Patterns

Geoff Huntley's specific phrasing that matters:
- "study" (not "read" or "look at")
- "don't assume not implemented" (critical - the Achilles' heel)
- "using parallel subagents" / "up to N subagents"
- "only 1 subagent for build/tests" (backpressure control)
- "Ultrathink"
- "capture the why"
- "keep it up to date"
- "if functionality is missing then it's your job to add it"
- "resolve them or document them"

## Safety

Ralph requires `--dangerously-skip-permissions` to run autonomously. This bypasses all permission prompts.

**Critical:** Run in isolated sandbox environments:
- Docker containers (local)
- Fly Sprites / E2B (remote)
- Minimum viable access (only needed API keys)
- No access to private data beyond requirements

Philosophy: "It's not if it gets popped, it's when. And what is the blast radius?"

## Escape Hatches

- Ctrl+C stops the loop
- `git reset --hard` reverts uncommitted changes
- Regenerate plan if trajectory goes wrong
- Plan regeneration cost = one Planning loop (cheap)

## Why It Works

1. **Fresh context** - No degradation from context pollution
2. **Deterministic setup** - Same files loaded each iteration
3. **File-based state** - Plan persists, learnings accumulate
4. **Backpressure** - Tests force correctness
5. **Eventual consistency** - Iteration converges to solution
6. **Simplicity** - Dumb bash loop, smart file I/O

---

*Methodology developed by [Geoff Huntley](https://ghuntley.com/ralph/)*
